const fs = require('fs')
const path = require('path')
const dotenv = require('dotenv')
const readlineSync = require('readline-sync')
const findRoot = require('find-root')
const prettier = require('prettier')
const validateNpmPackageName = require('validate-npm-package-name')
const { compile } = require('handlebars')
const glob = require('fast-glob')
const JSONWithComments = require('comment-json')
const prettierConfig = require('../../prettier')
const { isValidRepoSshAddress, getRepoSshAddress } = require('./repo-address')

const getTestsRootDir = ctx => {
  try {
    return findRoot(path.join(ctx.cwd, 'e2e-tests'), dir => {
      return path.basename(dir) === 'e2e-tests' && ctx.fs.existsSync(dir)
    })
  } catch (e) {
    throw new Error(`Could not find e2e-tests/ folder from ${ctx.cwd}`)
  }
}

function getProjectRootDir(ctx) {
  try {
    const result = findRoot(ctx.cwd, dir => {
      const gitExists = ctx.fs.existsSync(path.join(dir, '.git'))
      const packageJsonExists =
        ctx.fs.existsSync(path.join(dir, 'package.json')) && path.basename(dir) !== 'e2e-tests'
      return gitExists || packageJsonExists
    })

    return result
  } catch (e) {
    throw new Error(`Could not find project root`)
  }
}

function getConfigPath(ctx) {
  return path.join(getTestsRootDir(ctx), 'e2e-tools.json')
}

function getConfig(ctx) {
  try {
    const configFile = ctx.fs.readFileSync(getConfigPath(ctx), {
      encoding: 'utf-8',
    })

    return JSONWithComments.parse(configFile)
  } catch (err) {
    if (err && err.code === 'ENOENT') {
      throw new Error(`Config file ${err.path} was not found`)
    }

    throw err
  }
}

function runSafe(fn) {
  try {
    return fn()
  } catch (e) {
    return undefined
  }
}

function getParentProjectPackageJsonSafe(ctx) {
  try {
    return require(path.join(getProjectRootDir(ctx), 'package.json'))
  } catch (e) {
    return undefined
  }
}

function createJsonFile(ctx, { filePath, fileContent }) {
  const formattedContent = prettier.format(JSONWithComments.stringify(fileContent), {
    parser: 'json',
  })
  ctx.fs.mkdirSync(path.dirname(filePath), { recursive: true })
  ctx.fs.writeFileSync(filePath, formattedContent)
}

function formatFile(ctx, filePath) {
  const ext = path.extname(filePath)
  const parser = {
    '.js': 'babel',
    '.json': 'json',
  }[ext]

  if (!parser) {
    return
  }

  const fileContent = ctx.fs.readFileSync(filePath, 'utf8')
  const formattedContent = prettier.format(fileContent, { ...prettierConfig, parser })
  ctx.fs.writeFileSync(filePath, formattedContent)
}

function updateJsonFile(ctx, { filePath, update }) {
  const file = ctx.fs.readFileSync(filePath, { encoding: 'utf-8' })
  const fileContent = JSONWithComments.parse(file)
  createJsonFile(ctx, { filePath, fileContent: update(fileContent) })
}

function updateToolConfig(ctx, tool, update) {
  updateJsonFile(ctx, {
    filePath: getConfigPath(ctx),
    update(config) {
      const toolSettings = config.tools[tool]

      if (!toolSettings) {
        throw new Error(`Tool ${tool} was not found`)
      }

      const updatedToolSettings = update(toolSettings === true ? {} : toolSettings)

      return {
        ...config,
        tools: {
          ...config.tools,
          [tool]: Object.keys(updatedToolSettings).length === 0 ? true : updatedToolSettings,
        },
      }
    },
  })
}

function getRepoNameByAddress(str) {
  const matched = str.match(/\/(.*).git$/)

  if (!matched) {
    return undefined
  }

  return matched[1]
}

function validatePackageName(name) {
  if (name.startsWith('@')) {
    return false
  }

  return validateNpmPackageName(name).validForNewPackages
}

function getEnvVariable(ctx, variable, description) {
  try {
    const envFilePath = path.join(getTestsRootDir(ctx), '.env')

    if (!ctx.fs.existsSync(envFilePath)) {
      ctx.fs.writeFileSync(envFilePath, '\n')
    }

    const config = dotenv.config()
    if (process.env[variable]) {
      return process.env[variable]
    }

    const value = readlineSync.question(`${description} (${variable}) `)

    const newConfig = { ...config.parsed, [variable]: value }

    const envFileContent =
      Object.keys(newConfig)
        .map(key => `${key}=${newConfig[key]}`)
        .join('\n') + '\n'

    ctx.fs.writeFileSync(envFilePath, envFileContent)

    return newConfig[variable]
  } catch (err) {
    console.log(`Произошла ошибка при получении ${variable}`)
    throw err
  }
}

function defaultGetDestinationPath(templatePath) {
  return templatePath.replace(/\.hbs$/, '').replace(/\.autogenerated$/, '')
}

function createFilesFromTemplates_old({
  templatesGlob,
  templatesData,
  templatesRoot,
  destinationRoot,
  getDestinationPath = defaultGetDestinationPath,
}) {
  const templatesPaths = glob.sync(templatesGlob, {
    dot: true,
    cwd: templatesRoot,
  })

  templatesPaths.forEach(templatePath => {
    const templateAbsolutePath = path.join(templatesRoot, templatePath)
    const destinationPath = getDestinationPath(templatePath)
    const destinationAbsolutePath = path.join(destinationRoot, destinationPath)

    fs.mkdirSync(path.dirname(destinationAbsolutePath), { recursive: true })
    const render = compile(fs.readFileSync(templateAbsolutePath, 'utf8'))
    fs.writeFileSync(destinationAbsolutePath, render(templatesData))
    formatFile(destinationAbsolutePath)
  })
}

function createFilesFromTemplates(
  ctx,
  {
    templatesGlob,
    templatesData,
    templatesRoot,
    destinationRoot,
    getDestinationPath = defaultGetDestinationPath,
  }
) {
  const templatesPaths = glob.sync(templatesGlob, {
    dot: true,
    cwd: templatesRoot,
  })

  templatesPaths.forEach(templatePath => {
    const templateAbsolutePath = path.join(templatesRoot, templatePath)
    const destinationPath = getDestinationPath(templatePath)
    const destinationAbsolutePath = path.join(destinationRoot, destinationPath)

    ctx.fs.mkdirSync(path.dirname(destinationAbsolutePath), { recursive: true })
    const render = compile(fs.readFileSync(templateAbsolutePath, 'utf8'))
    ctx.fs.writeFileSync(destinationAbsolutePath, render(templatesData))
    formatFile(ctx, destinationAbsolutePath)
  })
}

module.exports = {
  getTestsRootDir,
  getProjectRootDir,
  getConfig,
  runSafe,
  createJsonFile,
  updateJsonFile,
  updateToolConfig,
  getParentProjectPackageJsonSafe,
  getRepoNameByAddress,
  validatePackageName,
  getEnvVariable,
  createFilesFromTemplates,
  isValidRepoSshAddress,
  getRepoSshAddress,
}
